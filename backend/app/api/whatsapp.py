"""
WhatsApp webhook endpoints for Twilio integration.
Handles incoming messages and status updates.
"""
from fastapi import APIRouter, Request, HTTPException, BackgroundTasks, Depends
from fastapi.responses import PlainTextResponse
from typing import Dict, Any, Optional
from datetime import datetime
import logging
import uuid

from ..services.twilio_whatsapp import twilio_service, send_automated_greeting
from ..models.customer import Customer
from ..models.whatsapp import WhatsAppMessage
from ..database import db_manager
from .auth import current_active_user
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

logger = logging.getLogger(__name__)

router = APIRouter(tags=["WhatsApp"])

@router.get("/test")
async def test_webhook():
    """Test endpoint to verify deployment"""
    return {"status": "webhook_v2_deployed", "timestamp": "2025-08-25-10:27"}

@router.post("/webhook")
async def whatsapp_webhook(request: Request):
    """
    Handle incoming WhatsApp messages from Twilio.
    Process customer responses and trigger appropriate actions.
    """
    try:
        logger.info("=== WEBHOOK CALLED ===")
        
        # Get form data from Twilio
        form_data = await request.form()
        
        # Extract message details
        from_number = form_data.get('From', '').replace('whatsapp:', '')
        message_body = form_data.get('Body', '')
        
        logger.info(f"Message from {from_number}: {message_body}")
        
        # Generate simple AI response without database
        ai_response = get_simple_ai_response(message_body)
        
        # Send response using Twilio
        try:
            from ..services.twilio_whatsapp import twilio_service
            
            # Create minimal customer object
            class SimpleCustomer:
                phone_number = from_number
                preferred_language = 'ar'
            
            customer = SimpleCustomer()
            
            await twilio_service.send_message(
                customer=customer,
                custom_message=ai_response
            )
            
            logger.info(f"Sent response to {from_number}")
            
        except Exception as send_error:
            logger.error(f"Error sending message: {send_error}")
            # Still return OK to Twilio
        
        return PlainTextResponse("OK", status_code=200)
        
    except Exception as e:
        logger.error(f"Error processing WhatsApp webhook: {str(e)}")
        # Still return 200 to prevent Twilio retries
        return PlainTextResponse("Error", status_code=200)

@router.post("/status")
async def whatsapp_status_webhook(request: Request):
    """Handle message status updates from Twilio."""
    try:
        form_data = await request.form()
        message_sid = form_data.get('MessageSid', '')
        status = form_data.get('MessageStatus', '')
        
        logger.info(f"Message {message_sid} status: {status}")
        
        # Update message status in database
        async with db_manager.get_session() as session:
            result = await session.execute(
                select(WhatsAppMessage).where(
                    WhatsAppMessage.whatsapp_message_id == message_sid
                )
            )
            message = result.scalar_one_or_none()
            
            if message:
                if status == 'delivered':
                    message.mark_delivered()
                elif status == 'read':
                    message.mark_read()
                elif status == 'failed':
                    message.mark_failed()
                
                await session.commit()
        
        return PlainTextResponse("OK", status_code=200)
        
    except Exception as e:
        logger.error(f"Error processing status webhook: {str(e)}")
        return PlainTextResponse("Error", status_code=200)

def get_simple_ai_response(message: str) -> str:
    """Generate simple AI response without database dependencies"""
    message_lower = message.lower().strip()
    
    # Greeting
    if any(word in message_lower for word in ['ูุฑุญุจุง', 'ุงูุณูุงู', 'ุฃููุง', 'hello', 'hi']):
        return """ูุฑุญุจุงู ุจูู ูู ูุทุนููุง! ๐

ููู ูููููู ูุณุงุนุฏุชููุ
โข ุญุฌุฒ ุทุงููุฉ  
โข ูุงุฆูุฉ ุงูุทุนุงู
โข ุชูููู ุงูุฎุฏูุฉ

ูุญู ููุง ูุฎุฏูุชูู! ๐"""

    # Booking
    elif any(word in message_lower for word in ['ุญุฌุฒ', 'ุทุงููุฉ', 'book']):
        return """ููุชุงุฒ! ูุญุฌุฒ ุทุงููุฉ ๐ช

ุฃุฎุจุฑููุง:
๐ ุงูุชุงุฑูุฎุ
๐ ุงูููุชุ  
๐ฅ ูู ุดุฎุตุ

ูููููู ุงูุงุชุตุงู ุจูุง ููุญุฌุฒ ุงููุจุงุดุฑ!"""

    # Menu
    elif any(word in message_lower for word in ['ูููู', 'ุทุนุงู', 'menu']):
        return """ูุงุฆูุฉ ุทุนุงููุง ๐ฝ๏ธ

๐ฅ ุฃุทุจุงู ุฑุฆูุณูุฉ
๐ฒ ุดูุฑุจุงุช ูููุจูุงุช
๐ฅ ุณูุทุงุช ุทุงุฒุฌุฉ
๐ง ูุดุฑูุจุงุช
๐ฐ ุญูููุงุช

ูุงุฐุง ุชูุถูููุ"""

    # Thanks
    elif any(word in message_lower for word in ['ุดูุฑุง', 'ุดูุฑุงู', 'thank']):
        return """ุงูุนูู! ูุณุนุฏูุง ุฎุฏูุชูู ๐

ูุชุทูุน ูุงุณุชูุจุงููู ูุฑูุจุงู! โจ"""

    # Default
    else:
        return """ุดูุฑุงู ูุชูุงุตููู! ๐ฑ

ูููููู ูุชุงุจุฉ:
๐น "ุญุฌุฒ" ููุญุฌูุฒุงุช
๐น "ูููู" ููุงุฆูุฉ ุงูุทุนุงู
๐น "ูุฑุญุจุง" ููุชุฑุญูุจ

ููู ูููููู ูุณุงุนุฏุชููุ ๐"""

async def generate_ai_response(customer: Customer, message: str, session: AsyncSession) -> Optional[str]:
    """Generate intelligent AI response based on customer message"""
    try:
        # Simple pattern matching for now
        message_lower = message.lower().strip()
        
        # Greeting responses
        if any(word in message_lower for word in ['ูุฑุญุจุง', 'ุงูุณูุงู', 'ุฃููุง', 'hello', 'hi']):
            return """ูุฑุญุจุงู ุจูู ูู ูุทุนููุง! ๐

ููู ูููููู ูุณุงุนุฏุชูู ุงููููุ
โข ููุญุฌุฒ: ุงูุชุจูุง "ุญุฌุฒ"  
โข ูุขุฑุงุกูู: ุงูุชุจูุง "ุชูููู"
โข ููุงุณุชูุณุงุฑ: ุงูุชุจูุง "ุงุณุชูุณุงุฑ"

ูุญู ููุง ูุฎุฏูุชูู! ๐"""

        # Booking requests
        elif any(word in message_lower for word in ['ุญุฌุฒ', 'ุทุงููุฉ', 'book', 'reservation']):
            return """ููุชุงุฒ! ุณูุณุงุนุฏูู ูู ุญุฌุฒ ุทุงููุฉ ๐ช

ูุฑุฌู ุฅุฎุจุงุฑูุง ุจุงูุชูุงุตูู ุงูุชุงููุฉ:
๐ ุงูุชุงุฑูุฎ ุงููุทููุจ
๐ ุงูููุช ุงูููุถู  
๐ฅ ุนุฏุฏ ุงูุฃุดุฎุงุต

ูููููู ุฃูุถุงู ุงูุงุชุตุงู ุจูุง ูุจุงุดุฑุฉ ููุญุฌุฒ ุงูุณุฑูุน!"""

        # Feedback/Rating
        elif any(word in message_lower for word in ['ุชูููู', 'ุฑุฃู', 'feedback', 'review']):
            return """ูุดูุฑูู ูุงูุชูุงููู ุจุชูููู ุฎุฏูุชูุง! โญ

ููู ูุงูุช ุชุฌุฑุจุชูู ูุนูุงุ
ูู 1 ุฅูู 5:
1๏ธโฃ ุบูุฑ ุฑุงุถ  
2๏ธโฃ ููุจูู
3๏ธโฃ ุฌูุฏ
4๏ธโฃ ููุชุงุฒ  
5๏ธโฃ ุงุณุชุซูุงุฆู

ุฑุฃููู ููู ุฌุฏุงู ููุง! ๐"""

        # Menu inquiry
        elif any(word in message_lower for word in ['ูููู', 'ุทุนุงู', 'ุฃุทุจุงู', 'menu', 'food']):
            return """ูุงุฆูุฉ ุทุนุงููุง ุงูุดููุฉ! ๐ฝ๏ธ

๐ฅ ุงูุฃุทุจุงู ุงูุฑุฆูุณูุฉ
๐ฒ ุงูุดูุฑุจุงุช ูุงูููุจูุงุช
๐ฅ ุงูุณูุทุงุช ุงูุทุงุฒุฌุฉ
๐ง ุงููุดุฑูุจุงุช ูุงูุนุตุงุฆุฑ
๐ฐ ุงูุญูููุงุช

ุฃู ููุน ูู ุงูุฃุทุจุงู ุชูุถูููุ"""

        # Thanks message
        elif any(word in message_lower for word in ['ุดูุฑุง', 'ุดูุฑุงู', 'thank', 'thanks']):
            return """ุงูุนูู! ูุณุนุฏูุง ุฎุฏูุชูู ุฏุงุฆูุงู ๐

ุฅุฐุง ูุงู ูุฏููู ุฃู ุงุณุชูุณุงุฑ ุขุฎุฑ ุฃู ุชุญุชุงุฌูู ูุณุงุนุฏุฉุ ูุง ุชุชุฑุฏุฏูุง ูู ุงูุชูุงุตู ูุนูุง.

ูุชุทูุน ูุงุณุชูุจุงููู ูุฑูุจุงู! โจ"""

        # Default intelligent response
        else:
            return """ุดูุฑุงู ูุชูุงุตููู ูุนูุง! ๐ฑ

ูู ุฃููู ุทูุจูู ุชูุงูุงูุ ููู ูููููู:

๐น ูุชุงุจุฉ "ุญุฌุฒ" ููุญุฌูุฒุงุช
๐น ูุชุงุจุฉ "ูููู" ููุงุฆูุฉ ุงูุทุนุงู  
๐น ูุชุงุจุฉ "ุชูููู" ูุชูููู ุงูุฎุฏูุฉ
๐น ุงูุงุชุตุงู ุจูุง ูุจุงุดุฑุฉ ูููุณุงุนุฏุฉ

ููู ูููููู ูุณุงุนุฏุชููุ ๐"""

    except Exception as e:
        logger.error(f"Error generating AI response: {str(e)}")
        return "ุดูุฑุงู ูุฑุณุงูุชูู! ุณูุชูุงุตู ูุนูู ูุฑูุจุงู ๐"

async def process_customer_response(
    customer: Customer, 
    message: str, 
    session: AsyncSession
) -> Optional[str]:
    """
    Process customer response and generate appropriate reply.
    
    Returns:
        Response message to send back to customer, or None
    """
    # Normalize message
    message = message.strip().lower()
    
    # Check for rating responses (1-4)
    if message in ['1', '2', '3', '4']:
        rating = int(message)
        
        # Update customer feedback
        customer.rating = rating
        customer.feedback_received_at = datetime.utcnow()
        
        # Set sentiment based on rating
        if rating >= 4:
            customer.feedback_sentiment = 'positive'
            sentiment_emoji = '๐'
        elif rating == 3:
            customer.feedback_sentiment = 'neutral'
            sentiment_emoji = '๐'
        else:
            customer.feedback_sentiment = 'negative'
            sentiment_emoji = '๐'
        
        # Generate response based on rating
        if customer.preferred_language == 'ar':
            if rating >= 4:
                response = """ุฑุงุฆุน! ูุณุนุฏูุง ุฃู ุชุฌุฑุจุชูู ูุงูุช ููุชุงุฒุฉ! ๐

ูู ูููููู ูุณุงุนุฏุชูุง ุจูุดุงุฑูุฉ ุชุฌุฑุจุชูู ุงูุฅูุฌุงุจูุฉ ุนูู Googleุ 
ุชูููููู ูุณุงุนุฏูุง ูุซูุฑุงู.

https://g.page/r/YOUR_GOOGLE_REVIEW_LINK

ุดูุฑุงู ููู ููุชุทูุน ูุฑุคูุชูู ูุฑูุจุงู! ๐"""
            elif rating == 3:
                response = """ุดูุฑุงู ูุชูููููู! ูุณุนู ุฏุงุฆูุงู ููุชุญุณูู. 

ูู ูููููู ูุดุงุฑูุฉ ุงููุฒูุฏ ุนู ุชุฌุฑุจุชููุ 
ูุง ุงูุฐู ูููููุง ุชุญุณููู ูุฌุนู ุฒูุงุฑุชูู ุงููุงุฏูุฉ ุฃูุถูุ"""
            else:
                response = """ูุฃุณู ูุณูุงุน ุฐูู. ุฑุฃููู ููู ุฌุฏุงู ููุง. ๐

ูู ูููููู ูุดุงุฑูุชูุง ุงููุฒูุฏ ุนู ุชุฌุฑุจุชููุ 
ูุง ุงูุฐู ูููููุง ุชุญุณูููุ

ูุฏูุฑูุง ุณูุชูุงุตู ูุนูู ุดุฎุตูุงู ูุญู ุฃู ูุดููุฉ.
ููุฏุฑ ุตุฑุงุญุชูู ููุนุฏูู ุจุชุญุณูู ุฎุฏูุงุชูุง. ๐"""
        else:
            if rating >= 4:
                response = """Wonderful! We're thrilled you had an excellent experience! ๐

Would you mind sharing your positive experience on Google? 
Your review helps us greatly.

https://g.page/r/YOUR_GOOGLE_REVIEW_LINK

Thank you and we look forward to seeing you again! ๐"""
            elif rating == 3:
                response = """Thank you for your feedback! We're always looking to improve.

Could you share more about your experience? 
What can we do better for your next visit?"""
            else:
                response = """We're sorry to hear that. Your feedback is very important to us. ๐

Could you please share more about your experience? 
What can we improve?

Our manager will contact you personally to resolve any issues.
We appreciate your honesty and promise to improve. ๐"""
        
        # Mark customer as needing follow-up if negative
        if rating <= 2:
            customer.requires_follow_up = True
            customer.follow_up_notes = f"Customer rated experience as {rating}/4"
        
        # Request Google review if positive
        if rating >= 4:
            customer.google_review_requested_at = datetime.utcnow()
            customer.google_review_link_sent = True
        
        return response
    
    # Check for other keywords
    elif any(word in message for word in ['ุดูุฑุง', 'thank', 'ูุดููุฑ', 'ุชูุงู', 'ok']):
        if customer.preferred_language == 'ar':
            return "ุนููุงู! ูุชููู ููู ูููุงู ุณุนูุฏุงู ๐"
        else:
            return "You're welcome! Have a wonderful day! ๐"
    
    # Store as general feedback if not a rating
    else:
        customer.feedback_text = message
        customer.feedback_received_at = datetime.utcnow()
        
        # Simple sentiment detection
        negative_words = ['ุณูุก', 'bad', 'poor', 'terrible', 'horrible', 'worst']
        positive_words = ['ููุชุงุฒ', 'ุฑุงุฆุน', 'excellent', 'great', 'amazing', 'wonderful']
        
        if any(word in message for word in negative_words):
            customer.feedback_sentiment = 'negative'
            customer.requires_follow_up = True
        elif any(word in message for word in positive_words):
            customer.feedback_sentiment = 'positive'
        
        if customer.preferred_language == 'ar':
            return "ุดูุฑุงู ูููุงุญุธุงุชูู ุงููููุฉ! ุณูุญุฑุต ุนูู ุงูุงุณุชูุงุฏุฉ ูููุง ูุชุญุณูู ุฎุฏูุงุชูุง. ๐"
        else:
            return "Thank you for your valuable feedback! We'll use it to improve our services. ๐"
    
    return None

@router.post("/send-test")
async def send_test_message(
    phone_number: str,
    current_user = Depends(current_active_user)
):
    """
    Send a test WhatsApp message to verify integration.
    Requires authentication.
    """
    result = await twilio_service.send_test_message(phone_number)
    
    if not result['success']:
        raise HTTPException(status_code=400, detail=result['message'])
    
    return result

@router.get("/sandbox-info")
async def get_sandbox_info():
    """Get Twilio WhatsApp sandbox joining instructions."""
    return twilio_service.get_sandbox_instructions()

@router.post("/send-greeting/{customer_id}")
async def send_greeting_message(
    customer_id: str,
    background_tasks: BackgroundTasks,
    delay_hours: float = 0,
    current_user = Depends(current_active_user)
):
    """
    Send greeting message to a specific customer.
    Can be immediate or delayed.
    """
    if delay_hours > 0:
        # Schedule for later
        background_tasks.add_task(
            send_automated_greeting,
            customer_id=customer_id,
            delay_hours=delay_hours
        )
        return {
            "message": f"Greeting scheduled to be sent in {delay_hours} hours",
            "customer_id": customer_id
        }
    else:
        # Send immediately
        async with db_manager.get_session() as session:
            # Handle UUID conversion - try direct string first, then UUID conversion
            try:
                if len(customer_id) == 32:  # UUID without hyphens
                    # Convert to UUID with hyphens for SQLAlchemy
                    uuid_str = f"{customer_id[:8]}-{customer_id[8:12]}-{customer_id[12:16]}-{customer_id[16:20]}-{customer_id[20:]}"
                    customer_uuid = uuid.UUID(uuid_str)
                else:
                    customer_uuid = uuid.UUID(customer_id)
                
                customer = await session.get(Customer, customer_uuid)
            except (ValueError, TypeError):
                # Try direct string lookup if UUID conversion fails
                result = await session.execute(
                    select(Customer).where(Customer.id == customer_id)
                )
                customer = result.scalar_one_or_none()
            
            if not customer:
                raise HTTPException(status_code=404, detail="Customer not found")
            
            result = await twilio_service.send_message(customer, 'greeting')
            
            if not result['success']:
                raise HTTPException(status_code=400, detail=result['message'])
            
            return result

@router.post("/test-greeting/{customer_id}")
async def test_send_greeting_message(
    customer_id: str
):
    """
    Test endpoint to send greeting message without authentication.
    For testing purposes only.
    """
    async with db_manager.get_session() as session:
        # Handle UUID conversion - try direct string first, then UUID conversion
        try:
            if len(customer_id) == 32:  # UUID without hyphens
                # Convert to UUID with hyphens for SQLAlchemy
                uuid_str = f"{customer_id[:8]}-{customer_id[8:12]}-{customer_id[12:16]}-{customer_id[16:20]}-{customer_id[20:]}"
                customer_uuid = uuid.UUID(uuid_str)
            else:
                customer_uuid = uuid.UUID(customer_id)
            
            customer = await session.get(Customer, customer_uuid)
        except (ValueError, TypeError):
            # Try direct string lookup if UUID conversion fails
            result = await session.execute(
                select(Customer).where(Customer.id == customer_id)
            )
            customer = result.scalar_one_or_none()
        
        if not customer:
            raise HTTPException(status_code=404, detail="Customer not found")
        
        result = await twilio_service.send_message(customer, 'greeting')
        
        if not result['success']:
            raise HTTPException(status_code=400, detail=result['message'])
        
        return result